// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `rollingmill_model.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Arrival {
    // message fields
    pub Vehicle: i32,
    pub Load: ::protobuf::SingularPtrField<Stack>,
    pub ArrivalEstimate: ::protobuf::SingularPtrField<TimeStamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Arrival {
    fn default() -> &'a Arrival {
        <Arrival as ::protobuf::Message>::default_instance()
    }
}

impl Arrival {
    pub fn new() -> Arrival {
        ::std::default::Default::default()
    }

    // int32 Vehicle = 1;


    pub fn get_Vehicle(&self) -> i32 {
        self.Vehicle
    }
    pub fn clear_Vehicle(&mut self) {
        self.Vehicle = 0;
    }

    // Param is passed by value, moved
    pub fn set_Vehicle(&mut self, v: i32) {
        self.Vehicle = v;
    }

    // .DynStacking.RollingMill.DataModel.Stack Load = 2;


    pub fn get_Load(&self) -> &Stack {
        self.Load.as_ref().unwrap_or_else(|| Stack::default_instance())
    }
    pub fn clear_Load(&mut self) {
        self.Load.clear();
    }

    pub fn has_Load(&self) -> bool {
        self.Load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Load(&mut self, v: Stack) {
        self.Load = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Load(&mut self) -> &mut Stack {
        if self.Load.is_none() {
            self.Load.set_default();
        }
        self.Load.as_mut().unwrap()
    }

    // Take field
    pub fn take_Load(&mut self) -> Stack {
        self.Load.take().unwrap_or_else(|| Stack::new())
    }

    // .DynStacking.RollingMill.DataModel.TimeStamp ArrivalEstimate = 3;


    pub fn get_ArrivalEstimate(&self) -> &TimeStamp {
        self.ArrivalEstimate.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_ArrivalEstimate(&mut self) {
        self.ArrivalEstimate.clear();
    }

    pub fn has_ArrivalEstimate(&self) -> bool {
        self.ArrivalEstimate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ArrivalEstimate(&mut self, v: TimeStamp) {
        self.ArrivalEstimate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ArrivalEstimate(&mut self) -> &mut TimeStamp {
        if self.ArrivalEstimate.is_none() {
            self.ArrivalEstimate.set_default();
        }
        self.ArrivalEstimate.as_mut().unwrap()
    }

    // Take field
    pub fn take_ArrivalEstimate(&mut self) -> TimeStamp {
        self.ArrivalEstimate.take().unwrap_or_else(|| TimeStamp::new())
    }
}

impl ::protobuf::Message for Arrival {
    fn is_initialized(&self) -> bool {
        for v in &self.Load {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ArrivalEstimate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Vehicle = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Load)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ArrivalEstimate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Vehicle != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Vehicle, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Load.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ArrivalEstimate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Vehicle != 0 {
            os.write_int32(1, self.Vehicle)?;
        }
        if let Some(ref v) = self.Load.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ArrivalEstimate.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Arrival {
        Arrival::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Vehicle",
                    |m: &Arrival| { &m.Vehicle },
                    |m: &mut Arrival| { &mut m.Vehicle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stack>>(
                    "Load",
                    |m: &Arrival| { &m.Load },
                    |m: &mut Arrival| { &mut m.Load },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "ArrivalEstimate",
                    |m: &Arrival| { &m.ArrivalEstimate },
                    |m: &mut Arrival| { &mut m.ArrivalEstimate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Arrival>(
                    "Arrival",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Arrival {
        static mut instance: ::protobuf::lazy::Lazy<Arrival> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Arrival,
        };
        unsafe {
            instance.get(Arrival::new)
        }
    }
}

impl ::protobuf::Clear for Arrival {
    fn clear(&mut self) {
        self.Vehicle = 0;
        self.Load.clear();
        self.ArrivalEstimate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Arrival {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Arrival {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub Id: i32,
    pub Sequence: i32,
    pub Type: MillTypes,
    pub ProgramId: i32,
    pub Arrived: ::protobuf::SingularPtrField<TimeStamp>,
    pub Rolled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // int32 Sequence = 2;


    pub fn get_Sequence(&self) -> i32 {
        self.Sequence
    }
    pub fn clear_Sequence(&mut self) {
        self.Sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_Sequence(&mut self, v: i32) {
        self.Sequence = v;
    }

    // .DynStacking.RollingMill.DataModel.MillTypes Type = 3;


    pub fn get_Type(&self) -> MillTypes {
        self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type = MillTypes::A;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: MillTypes) {
        self.Type = v;
    }

    // int32 ProgramId = 4;


    pub fn get_ProgramId(&self) -> i32 {
        self.ProgramId
    }
    pub fn clear_ProgramId(&mut self) {
        self.ProgramId = 0;
    }

    // Param is passed by value, moved
    pub fn set_ProgramId(&mut self, v: i32) {
        self.ProgramId = v;
    }

    // .DynStacking.RollingMill.DataModel.TimeStamp Arrived = 5;


    pub fn get_Arrived(&self) -> &TimeStamp {
        self.Arrived.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_Arrived(&mut self) {
        self.Arrived.clear();
    }

    pub fn has_Arrived(&self) -> bool {
        self.Arrived.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Arrived(&mut self, v: TimeStamp) {
        self.Arrived = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Arrived(&mut self) -> &mut TimeStamp {
        if self.Arrived.is_none() {
            self.Arrived.set_default();
        }
        self.Arrived.as_mut().unwrap()
    }

    // Take field
    pub fn take_Arrived(&mut self) -> TimeStamp {
        self.Arrived.take().unwrap_or_else(|| TimeStamp::new())
    }

    // bool Rolled = 6;


    pub fn get_Rolled(&self) -> bool {
        self.Rolled
    }
    pub fn clear_Rolled(&mut self) {
        self.Rolled = false;
    }

    // Param is passed by value, moved
    pub fn set_Rolled(&mut self, v: bool) {
        self.Rolled = v;
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.Arrived {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Sequence = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ProgramId = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Arrived)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Rolled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Sequence != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Type != MillTypes::A {
            my_size += ::protobuf::rt::enum_size(3, self.Type);
        }
        if self.ProgramId != 0 {
            my_size += ::protobuf::rt::value_size(4, self.ProgramId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Arrived.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.Rolled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.Sequence != 0 {
            os.write_int32(2, self.Sequence)?;
        }
        if self.Type != MillTypes::A {
            os.write_enum(3, self.Type.value())?;
        }
        if self.ProgramId != 0 {
            os.write_int32(4, self.ProgramId)?;
        }
        if let Some(ref v) = self.Arrived.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.Rolled != false {
            os.write_bool(6, self.Rolled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Block| { &m.Id },
                    |m: &mut Block| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Sequence",
                    |m: &Block| { &m.Sequence },
                    |m: &mut Block| { &mut m.Sequence },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MillTypes>>(
                    "Type",
                    |m: &Block| { &m.Type },
                    |m: &mut Block| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ProgramId",
                    |m: &Block| { &m.ProgramId },
                    |m: &mut Block| { &mut m.ProgramId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "Arrived",
                    |m: &Block| { &m.Arrived },
                    |m: &mut Block| { &mut m.Arrived },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Rolled",
                    |m: &Block| { &m.Rolled },
                    |m: &mut Block| { &mut m.Rolled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.Id = 0;
        self.Sequence = 0;
        self.Type = MillTypes::A;
        self.ProgramId = 0;
        self.Arrived.clear();
        self.Rolled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Crane {
    // message fields
    pub Id: i32,
    pub Load: ::protobuf::SingularPtrField<Stack>,
    pub GirderPosition: f64,
    pub HoistLevel: f64,
    pub CraneCapacity: i32,
    pub Width: f64,
    pub MinPosition: f64,
    pub MaxPosition: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Crane {
    fn default() -> &'a Crane {
        <Crane as ::protobuf::Message>::default_instance()
    }
}

impl Crane {
    pub fn new() -> Crane {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // .DynStacking.RollingMill.DataModel.Stack Load = 2;


    pub fn get_Load(&self) -> &Stack {
        self.Load.as_ref().unwrap_or_else(|| Stack::default_instance())
    }
    pub fn clear_Load(&mut self) {
        self.Load.clear();
    }

    pub fn has_Load(&self) -> bool {
        self.Load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Load(&mut self, v: Stack) {
        self.Load = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Load(&mut self) -> &mut Stack {
        if self.Load.is_none() {
            self.Load.set_default();
        }
        self.Load.as_mut().unwrap()
    }

    // Take field
    pub fn take_Load(&mut self) -> Stack {
        self.Load.take().unwrap_or_else(|| Stack::new())
    }

    // double GirderPosition = 3;


    pub fn get_GirderPosition(&self) -> f64 {
        self.GirderPosition
    }
    pub fn clear_GirderPosition(&mut self) {
        self.GirderPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_GirderPosition(&mut self, v: f64) {
        self.GirderPosition = v;
    }

    // double HoistLevel = 4;


    pub fn get_HoistLevel(&self) -> f64 {
        self.HoistLevel
    }
    pub fn clear_HoistLevel(&mut self) {
        self.HoistLevel = 0.;
    }

    // Param is passed by value, moved
    pub fn set_HoistLevel(&mut self, v: f64) {
        self.HoistLevel = v;
    }

    // int32 CraneCapacity = 5;


    pub fn get_CraneCapacity(&self) -> i32 {
        self.CraneCapacity
    }
    pub fn clear_CraneCapacity(&mut self) {
        self.CraneCapacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_CraneCapacity(&mut self, v: i32) {
        self.CraneCapacity = v;
    }

    // double Width = 6;


    pub fn get_Width(&self) -> f64 {
        self.Width
    }
    pub fn clear_Width(&mut self) {
        self.Width = 0.;
    }

    // Param is passed by value, moved
    pub fn set_Width(&mut self, v: f64) {
        self.Width = v;
    }

    // double MinPosition = 7;


    pub fn get_MinPosition(&self) -> f64 {
        self.MinPosition
    }
    pub fn clear_MinPosition(&mut self) {
        self.MinPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_MinPosition(&mut self, v: f64) {
        self.MinPosition = v;
    }

    // double MaxPosition = 8;


    pub fn get_MaxPosition(&self) -> f64 {
        self.MaxPosition
    }
    pub fn clear_MaxPosition(&mut self) {
        self.MaxPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_MaxPosition(&mut self, v: f64) {
        self.MaxPosition = v;
    }
}

impl ::protobuf::Message for Crane {
    fn is_initialized(&self) -> bool {
        for v in &self.Load {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Load)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.GirderPosition = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.HoistLevel = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CraneCapacity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.Width = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.MinPosition = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.MaxPosition = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Load.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.GirderPosition != 0. {
            my_size += 9;
        }
        if self.HoistLevel != 0. {
            my_size += 9;
        }
        if self.CraneCapacity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.CraneCapacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Width != 0. {
            my_size += 9;
        }
        if self.MinPosition != 0. {
            my_size += 9;
        }
        if self.MaxPosition != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if let Some(ref v) = self.Load.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.GirderPosition != 0. {
            os.write_double(3, self.GirderPosition)?;
        }
        if self.HoistLevel != 0. {
            os.write_double(4, self.HoistLevel)?;
        }
        if self.CraneCapacity != 0 {
            os.write_int32(5, self.CraneCapacity)?;
        }
        if self.Width != 0. {
            os.write_double(6, self.Width)?;
        }
        if self.MinPosition != 0. {
            os.write_double(7, self.MinPosition)?;
        }
        if self.MaxPosition != 0. {
            os.write_double(8, self.MaxPosition)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Crane {
        Crane::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Crane| { &m.Id },
                    |m: &mut Crane| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stack>>(
                    "Load",
                    |m: &Crane| { &m.Load },
                    |m: &mut Crane| { &mut m.Load },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "GirderPosition",
                    |m: &Crane| { &m.GirderPosition },
                    |m: &mut Crane| { &mut m.GirderPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "HoistLevel",
                    |m: &Crane| { &m.HoistLevel },
                    |m: &mut Crane| { &mut m.HoistLevel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "CraneCapacity",
                    |m: &Crane| { &m.CraneCapacity },
                    |m: &mut Crane| { &mut m.CraneCapacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "Width",
                    |m: &Crane| { &m.Width },
                    |m: &mut Crane| { &mut m.Width },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "MinPosition",
                    |m: &Crane| { &m.MinPosition },
                    |m: &mut Crane| { &mut m.MinPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "MaxPosition",
                    |m: &Crane| { &m.MaxPosition },
                    |m: &mut Crane| { &mut m.MaxPosition },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Crane>(
                    "Crane",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Crane {
        static mut instance: ::protobuf::lazy::Lazy<Crane> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Crane,
        };
        unsafe {
            instance.get(Crane::new)
        }
    }
}

impl ::protobuf::Clear for Crane {
    fn clear(&mut self) {
        self.Id = 0;
        self.Load.clear();
        self.GirderPosition = 0.;
        self.HoistLevel = 0.;
        self.CraneCapacity = 0;
        self.Width = 0.;
        self.MinPosition = 0.;
        self.MaxPosition = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Crane {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Crane {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneMove {
    // message fields
    pub Id: i32,
    pub Type: MoveType,
    pub PickupLocationId: i32,
    pub DropoffLocationId: i32,
    pub Amount: i32,
    pub ReleaseTime: ::protobuf::SingularPtrField<TimeStamp>,
    pub DueDate: ::protobuf::SingularPtrField<TimeStamp>,
    pub RequiredCraneId: i32,
    pub ProtobufPredecessorIds: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneMove {
    fn default() -> &'a CraneMove {
        <CraneMove as ::protobuf::Message>::default_instance()
    }
}

impl CraneMove {
    pub fn new() -> CraneMove {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // .DynStacking.RollingMill.DataModel.MoveType Type = 2;


    pub fn get_Type(&self) -> MoveType {
        self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type = MoveType::MoveToPickup;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: MoveType) {
        self.Type = v;
    }

    // int32 PickupLocationId = 3;


    pub fn get_PickupLocationId(&self) -> i32 {
        self.PickupLocationId
    }
    pub fn clear_PickupLocationId(&mut self) {
        self.PickupLocationId = 0;
    }

    // Param is passed by value, moved
    pub fn set_PickupLocationId(&mut self, v: i32) {
        self.PickupLocationId = v;
    }

    // int32 DropoffLocationId = 4;


    pub fn get_DropoffLocationId(&self) -> i32 {
        self.DropoffLocationId
    }
    pub fn clear_DropoffLocationId(&mut self) {
        self.DropoffLocationId = 0;
    }

    // Param is passed by value, moved
    pub fn set_DropoffLocationId(&mut self, v: i32) {
        self.DropoffLocationId = v;
    }

    // int32 Amount = 7;


    pub fn get_Amount(&self) -> i32 {
        self.Amount
    }
    pub fn clear_Amount(&mut self) {
        self.Amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_Amount(&mut self, v: i32) {
        self.Amount = v;
    }

    // .DynStacking.RollingMill.DataModel.TimeStamp ReleaseTime = 8;


    pub fn get_ReleaseTime(&self) -> &TimeStamp {
        self.ReleaseTime.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_ReleaseTime(&mut self) {
        self.ReleaseTime.clear();
    }

    pub fn has_ReleaseTime(&self) -> bool {
        self.ReleaseTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReleaseTime(&mut self, v: TimeStamp) {
        self.ReleaseTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ReleaseTime(&mut self) -> &mut TimeStamp {
        if self.ReleaseTime.is_none() {
            self.ReleaseTime.set_default();
        }
        self.ReleaseTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_ReleaseTime(&mut self) -> TimeStamp {
        self.ReleaseTime.take().unwrap_or_else(|| TimeStamp::new())
    }

    // .DynStacking.RollingMill.DataModel.TimeStamp DueDate = 9;


    pub fn get_DueDate(&self) -> &TimeStamp {
        self.DueDate.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_DueDate(&mut self) {
        self.DueDate.clear();
    }

    pub fn has_DueDate(&self) -> bool {
        self.DueDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DueDate(&mut self, v: TimeStamp) {
        self.DueDate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DueDate(&mut self) -> &mut TimeStamp {
        if self.DueDate.is_none() {
            self.DueDate.set_default();
        }
        self.DueDate.as_mut().unwrap()
    }

    // Take field
    pub fn take_DueDate(&mut self) -> TimeStamp {
        self.DueDate.take().unwrap_or_else(|| TimeStamp::new())
    }

    // int32 RequiredCraneId = 10;


    pub fn get_RequiredCraneId(&self) -> i32 {
        self.RequiredCraneId
    }
    pub fn clear_RequiredCraneId(&mut self) {
        self.RequiredCraneId = 0;
    }

    // Param is passed by value, moved
    pub fn set_RequiredCraneId(&mut self, v: i32) {
        self.RequiredCraneId = v;
    }

    // repeated int32 ProtobufPredecessorIds = 11;


    pub fn get_ProtobufPredecessorIds(&self) -> &[i32] {
        &self.ProtobufPredecessorIds
    }
    pub fn clear_ProtobufPredecessorIds(&mut self) {
        self.ProtobufPredecessorIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProtobufPredecessorIds(&mut self, v: ::std::vec::Vec<i32>) {
        self.ProtobufPredecessorIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ProtobufPredecessorIds(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.ProtobufPredecessorIds
    }

    // Take field
    pub fn take_ProtobufPredecessorIds(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.ProtobufPredecessorIds, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CraneMove {
    fn is_initialized(&self) -> bool {
        for v in &self.ReleaseTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DueDate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.PickupLocationId = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.DropoffLocationId = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Amount = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ReleaseTime)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DueDate)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.RequiredCraneId = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.ProtobufPredecessorIds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Type != MoveType::MoveToPickup {
            my_size += ::protobuf::rt::enum_size(2, self.Type);
        }
        if self.PickupLocationId != 0 {
            my_size += ::protobuf::rt::value_size(3, self.PickupLocationId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DropoffLocationId != 0 {
            my_size += ::protobuf::rt::value_size(4, self.DropoffLocationId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Amount != 0 {
            my_size += ::protobuf::rt::value_size(7, self.Amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ReleaseTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DueDate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.RequiredCraneId != 0 {
            my_size += ::protobuf::rt::value_size(10, self.RequiredCraneId, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ProtobufPredecessorIds {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.Type != MoveType::MoveToPickup {
            os.write_enum(2, self.Type.value())?;
        }
        if self.PickupLocationId != 0 {
            os.write_int32(3, self.PickupLocationId)?;
        }
        if self.DropoffLocationId != 0 {
            os.write_int32(4, self.DropoffLocationId)?;
        }
        if self.Amount != 0 {
            os.write_int32(7, self.Amount)?;
        }
        if let Some(ref v) = self.ReleaseTime.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DueDate.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.RequiredCraneId != 0 {
            os.write_int32(10, self.RequiredCraneId)?;
        }
        for v in &self.ProtobufPredecessorIds {
            os.write_int32(11, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneMove {
        CraneMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &CraneMove| { &m.Id },
                    |m: &mut CraneMove| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MoveType>>(
                    "Type",
                    |m: &CraneMove| { &m.Type },
                    |m: &mut CraneMove| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "PickupLocationId",
                    |m: &CraneMove| { &m.PickupLocationId },
                    |m: &mut CraneMove| { &mut m.PickupLocationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "DropoffLocationId",
                    |m: &CraneMove| { &m.DropoffLocationId },
                    |m: &mut CraneMove| { &mut m.DropoffLocationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Amount",
                    |m: &CraneMove| { &m.Amount },
                    |m: &mut CraneMove| { &mut m.Amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "ReleaseTime",
                    |m: &CraneMove| { &m.ReleaseTime },
                    |m: &mut CraneMove| { &mut m.ReleaseTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "DueDate",
                    |m: &CraneMove| { &m.DueDate },
                    |m: &mut CraneMove| { &mut m.DueDate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "RequiredCraneId",
                    |m: &CraneMove| { &m.RequiredCraneId },
                    |m: &mut CraneMove| { &mut m.RequiredCraneId },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ProtobufPredecessorIds",
                    |m: &CraneMove| { &m.ProtobufPredecessorIds },
                    |m: &mut CraneMove| { &mut m.ProtobufPredecessorIds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneMove>(
                    "CraneMove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneMove {
        static mut instance: ::protobuf::lazy::Lazy<CraneMove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneMove,
        };
        unsafe {
            instance.get(CraneMove::new)
        }
    }
}

impl ::protobuf::Clear for CraneMove {
    fn clear(&mut self) {
        self.Id = 0;
        self.Type = MoveType::MoveToPickup;
        self.PickupLocationId = 0;
        self.DropoffLocationId = 0;
        self.Amount = 0;
        self.ReleaseTime.clear();
        self.DueDate.clear();
        self.RequiredCraneId = 0;
        self.ProtobufPredecessorIds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneMove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneSchedule {
    // message fields
    pub ScheduleNr: i32,
    pub Activities: ::protobuf::RepeatedField<CraneScheduleActivity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneSchedule {
    fn default() -> &'a CraneSchedule {
        <CraneSchedule as ::protobuf::Message>::default_instance()
    }
}

impl CraneSchedule {
    pub fn new() -> CraneSchedule {
        ::std::default::Default::default()
    }

    // int32 ScheduleNr = 1;


    pub fn get_ScheduleNr(&self) -> i32 {
        self.ScheduleNr
    }
    pub fn clear_ScheduleNr(&mut self) {
        self.ScheduleNr = 0;
    }

    // Param is passed by value, moved
    pub fn set_ScheduleNr(&mut self, v: i32) {
        self.ScheduleNr = v;
    }

    // repeated .DynStacking.RollingMill.DataModel.CraneScheduleActivity Activities = 2;


    pub fn get_Activities(&self) -> &[CraneScheduleActivity] {
        &self.Activities
    }
    pub fn clear_Activities(&mut self) {
        self.Activities.clear();
    }

    // Param is passed by value, moved
    pub fn set_Activities(&mut self, v: ::protobuf::RepeatedField<CraneScheduleActivity>) {
        self.Activities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Activities(&mut self) -> &mut ::protobuf::RepeatedField<CraneScheduleActivity> {
        &mut self.Activities
    }

    // Take field
    pub fn take_Activities(&mut self) -> ::protobuf::RepeatedField<CraneScheduleActivity> {
        ::std::mem::replace(&mut self.Activities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CraneSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.Activities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ScheduleNr = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Activities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ScheduleNr != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ScheduleNr, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.Activities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ScheduleNr != 0 {
            os.write_int32(1, self.ScheduleNr)?;
        }
        for v in &self.Activities {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneSchedule {
        CraneSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ScheduleNr",
                    |m: &CraneSchedule| { &m.ScheduleNr },
                    |m: &mut CraneSchedule| { &mut m.ScheduleNr },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneScheduleActivity>>(
                    "Activities",
                    |m: &CraneSchedule| { &m.Activities },
                    |m: &mut CraneSchedule| { &mut m.Activities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneSchedule>(
                    "CraneSchedule",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneSchedule {
        static mut instance: ::protobuf::lazy::Lazy<CraneSchedule> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneSchedule,
        };
        unsafe {
            instance.get(CraneSchedule::new)
        }
    }
}

impl ::protobuf::Clear for CraneSchedule {
    fn clear(&mut self) {
        self.ScheduleNr = 0;
        self.Activities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneScheduleActivity {
    // message fields
    pub MoveId: i32,
    pub CraneId: i32,
    pub Priority: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneScheduleActivity {
    fn default() -> &'a CraneScheduleActivity {
        <CraneScheduleActivity as ::protobuf::Message>::default_instance()
    }
}

impl CraneScheduleActivity {
    pub fn new() -> CraneScheduleActivity {
        ::std::default::Default::default()
    }

    // int32 MoveId = 1;


    pub fn get_MoveId(&self) -> i32 {
        self.MoveId
    }
    pub fn clear_MoveId(&mut self) {
        self.MoveId = 0;
    }

    // Param is passed by value, moved
    pub fn set_MoveId(&mut self, v: i32) {
        self.MoveId = v;
    }

    // int32 CraneId = 2;


    pub fn get_CraneId(&self) -> i32 {
        self.CraneId
    }
    pub fn clear_CraneId(&mut self) {
        self.CraneId = 0;
    }

    // Param is passed by value, moved
    pub fn set_CraneId(&mut self, v: i32) {
        self.CraneId = v;
    }

    // int32 Priority = 3;


    pub fn get_Priority(&self) -> i32 {
        self.Priority
    }
    pub fn clear_Priority(&mut self) {
        self.Priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_Priority(&mut self, v: i32) {
        self.Priority = v;
    }
}

impl ::protobuf::Message for CraneScheduleActivity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.MoveId = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CraneId = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Priority = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.MoveId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.MoveId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.CraneId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.CraneId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Priority != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Priority, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.MoveId != 0 {
            os.write_int32(1, self.MoveId)?;
        }
        if self.CraneId != 0 {
            os.write_int32(2, self.CraneId)?;
        }
        if self.Priority != 0 {
            os.write_int32(3, self.Priority)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneScheduleActivity {
        CraneScheduleActivity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "MoveId",
                    |m: &CraneScheduleActivity| { &m.MoveId },
                    |m: &mut CraneScheduleActivity| { &mut m.MoveId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "CraneId",
                    |m: &CraneScheduleActivity| { &m.CraneId },
                    |m: &mut CraneScheduleActivity| { &mut m.CraneId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Priority",
                    |m: &CraneScheduleActivity| { &m.Priority },
                    |m: &mut CraneScheduleActivity| { &mut m.Priority },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneScheduleActivity>(
                    "CraneScheduleActivity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneScheduleActivity {
        static mut instance: ::protobuf::lazy::Lazy<CraneScheduleActivity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneScheduleActivity,
        };
        unsafe {
            instance.get(CraneScheduleActivity::new)
        }
    }
}

impl ::protobuf::Clear for CraneScheduleActivity {
    fn clear(&mut self) {
        self.MoveId = 0;
        self.CraneId = 0;
        self.Priority = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneScheduleActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneScheduleActivity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Location {
    // message fields
    pub Id: i32,
    pub GirderPosition: f64,
    pub MaxHeight: i32,
    pub Stack: ::protobuf::SingularPtrField<Stack>,
    pub Type: StackTypes,
    pub MillType: MillTypes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Location {
    fn default() -> &'a Location {
        <Location as ::protobuf::Message>::default_instance()
    }
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // double GirderPosition = 2;


    pub fn get_GirderPosition(&self) -> f64 {
        self.GirderPosition
    }
    pub fn clear_GirderPosition(&mut self) {
        self.GirderPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_GirderPosition(&mut self, v: f64) {
        self.GirderPosition = v;
    }

    // int32 MaxHeight = 3;


    pub fn get_MaxHeight(&self) -> i32 {
        self.MaxHeight
    }
    pub fn clear_MaxHeight(&mut self) {
        self.MaxHeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_MaxHeight(&mut self, v: i32) {
        self.MaxHeight = v;
    }

    // .DynStacking.RollingMill.DataModel.Stack Stack = 4;


    pub fn get_Stack(&self) -> &Stack {
        self.Stack.as_ref().unwrap_or_else(|| Stack::default_instance())
    }
    pub fn clear_Stack(&mut self) {
        self.Stack.clear();
    }

    pub fn has_Stack(&self) -> bool {
        self.Stack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Stack(&mut self, v: Stack) {
        self.Stack = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Stack(&mut self) -> &mut Stack {
        if self.Stack.is_none() {
            self.Stack.set_default();
        }
        self.Stack.as_mut().unwrap()
    }

    // Take field
    pub fn take_Stack(&mut self) -> Stack {
        self.Stack.take().unwrap_or_else(|| Stack::new())
    }

    // .DynStacking.RollingMill.DataModel.StackTypes Type = 5;


    pub fn get_Type(&self) -> StackTypes {
        self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type = StackTypes::ArrivalStack;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: StackTypes) {
        self.Type = v;
    }

    // .DynStacking.RollingMill.DataModel.MillTypes MillType = 6;


    pub fn get_MillType(&self) -> MillTypes {
        self.MillType
    }
    pub fn clear_MillType(&mut self) {
        self.MillType = MillTypes::A;
    }

    // Param is passed by value, moved
    pub fn set_MillType(&mut self, v: MillTypes) {
        self.MillType = v;
    }
}

impl ::protobuf::Message for Location {
    fn is_initialized(&self) -> bool {
        for v in &self.Stack {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.GirderPosition = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.MaxHeight = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Stack)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.MillType, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.GirderPosition != 0. {
            my_size += 9;
        }
        if self.MaxHeight != 0 {
            my_size += ::protobuf::rt::value_size(3, self.MaxHeight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Stack.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.Type != StackTypes::ArrivalStack {
            my_size += ::protobuf::rt::enum_size(5, self.Type);
        }
        if self.MillType != MillTypes::A {
            my_size += ::protobuf::rt::enum_size(6, self.MillType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.GirderPosition != 0. {
            os.write_double(2, self.GirderPosition)?;
        }
        if self.MaxHeight != 0 {
            os.write_int32(3, self.MaxHeight)?;
        }
        if let Some(ref v) = self.Stack.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.Type != StackTypes::ArrivalStack {
            os.write_enum(5, self.Type.value())?;
        }
        if self.MillType != MillTypes::A {
            os.write_enum(6, self.MillType.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Location {
        Location::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Location| { &m.Id },
                    |m: &mut Location| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "GirderPosition",
                    |m: &Location| { &m.GirderPosition },
                    |m: &mut Location| { &mut m.GirderPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "MaxHeight",
                    |m: &Location| { &m.MaxHeight },
                    |m: &mut Location| { &mut m.MaxHeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stack>>(
                    "Stack",
                    |m: &Location| { &m.Stack },
                    |m: &mut Location| { &mut m.Stack },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StackTypes>>(
                    "Type",
                    |m: &Location| { &m.Type },
                    |m: &mut Location| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MillTypes>>(
                    "MillType",
                    |m: &Location| { &m.MillType },
                    |m: &mut Location| { &mut m.MillType },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Location>(
                    "Location",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Location {
        static mut instance: ::protobuf::lazy::Lazy<Location> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Location,
        };
        unsafe {
            instance.get(Location::new)
        }
    }
}

impl ::protobuf::Clear for Location {
    fn clear(&mut self) {
        self.Id = 0;
        self.GirderPosition = 0.;
        self.MaxHeight = 0;
        self.Stack.clear();
        self.Type = StackTypes::ArrivalStack;
        self.MillType = MillTypes::A;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveRequest {
    // message fields
    pub Id: i32,
    pub TargetLocationId: i32,
    pub BlockId: i32,
    pub DueDate: ::protobuf::SingularPtrField<TimeStamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveRequest {
    fn default() -> &'a MoveRequest {
        <MoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoveRequest {
    pub fn new() -> MoveRequest {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // int32 TargetLocationId = 2;


    pub fn get_TargetLocationId(&self) -> i32 {
        self.TargetLocationId
    }
    pub fn clear_TargetLocationId(&mut self) {
        self.TargetLocationId = 0;
    }

    // Param is passed by value, moved
    pub fn set_TargetLocationId(&mut self, v: i32) {
        self.TargetLocationId = v;
    }

    // int32 BlockId = 3;


    pub fn get_BlockId(&self) -> i32 {
        self.BlockId
    }
    pub fn clear_BlockId(&mut self) {
        self.BlockId = 0;
    }

    // Param is passed by value, moved
    pub fn set_BlockId(&mut self, v: i32) {
        self.BlockId = v;
    }

    // .DynStacking.RollingMill.DataModel.TimeStamp DueDate = 4;


    pub fn get_DueDate(&self) -> &TimeStamp {
        self.DueDate.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_DueDate(&mut self) {
        self.DueDate.clear();
    }

    pub fn has_DueDate(&self) -> bool {
        self.DueDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DueDate(&mut self, v: TimeStamp) {
        self.DueDate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DueDate(&mut self) -> &mut TimeStamp {
        if self.DueDate.is_none() {
            self.DueDate.set_default();
        }
        self.DueDate.as_mut().unwrap()
    }

    // Take field
    pub fn take_DueDate(&mut self) -> TimeStamp {
        self.DueDate.take().unwrap_or_else(|| TimeStamp::new())
    }
}

impl ::protobuf::Message for MoveRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.DueDate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.TargetLocationId = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.BlockId = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DueDate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TargetLocationId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.TargetLocationId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BlockId != 0 {
            my_size += ::protobuf::rt::value_size(3, self.BlockId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.DueDate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.TargetLocationId != 0 {
            os.write_int32(2, self.TargetLocationId)?;
        }
        if self.BlockId != 0 {
            os.write_int32(3, self.BlockId)?;
        }
        if let Some(ref v) = self.DueDate.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveRequest {
        MoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &MoveRequest| { &m.Id },
                    |m: &mut MoveRequest| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "TargetLocationId",
                    |m: &MoveRequest| { &m.TargetLocationId },
                    |m: &mut MoveRequest| { &mut m.TargetLocationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "BlockId",
                    |m: &MoveRequest| { &m.BlockId },
                    |m: &mut MoveRequest| { &mut m.BlockId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "DueDate",
                    |m: &MoveRequest| { &m.DueDate },
                    |m: &mut MoveRequest| { &mut m.DueDate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoveRequest>(
                    "MoveRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoveRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoveRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoveRequest,
        };
        unsafe {
            instance.get(MoveRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoveRequest {
    fn clear(&mut self) {
        self.Id = 0;
        self.TargetLocationId = 0;
        self.BlockId = 0;
        self.DueDate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Performance {
    // message fields
    pub CraneManipulations: i32,
    pub ServiceLevelMean: f64,
    pub LeadTimeMean: f64,
    pub DeliveredBlocks: i32,
    pub TotalBlocksOnTime: i32,
    pub TardinessMean: f64,
    pub ShuffleBufferUtilizationMean: f64,
    pub SortedBufferUtilizationMean: f64,
    pub ShuffleCraneUtilizationMean: f64,
    pub HandoverCraneUtilizationMean: f64,
    pub MillAUtilizationMean: f64,
    pub MillBUtilizationMean: f64,
    pub RollingProgramMessups: i32,
    pub BlockedMillTime: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Performance {
    fn default() -> &'a Performance {
        <Performance as ::protobuf::Message>::default_instance()
    }
}

impl Performance {
    pub fn new() -> Performance {
        ::std::default::Default::default()
    }

    // int32 CraneManipulations = 1;


    pub fn get_CraneManipulations(&self) -> i32 {
        self.CraneManipulations
    }
    pub fn clear_CraneManipulations(&mut self) {
        self.CraneManipulations = 0;
    }

    // Param is passed by value, moved
    pub fn set_CraneManipulations(&mut self, v: i32) {
        self.CraneManipulations = v;
    }

    // double ServiceLevelMean = 2;


    pub fn get_ServiceLevelMean(&self) -> f64 {
        self.ServiceLevelMean
    }
    pub fn clear_ServiceLevelMean(&mut self) {
        self.ServiceLevelMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ServiceLevelMean(&mut self, v: f64) {
        self.ServiceLevelMean = v;
    }

    // double LeadTimeMean = 3;


    pub fn get_LeadTimeMean(&self) -> f64 {
        self.LeadTimeMean
    }
    pub fn clear_LeadTimeMean(&mut self) {
        self.LeadTimeMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_LeadTimeMean(&mut self, v: f64) {
        self.LeadTimeMean = v;
    }

    // int32 DeliveredBlocks = 4;


    pub fn get_DeliveredBlocks(&self) -> i32 {
        self.DeliveredBlocks
    }
    pub fn clear_DeliveredBlocks(&mut self) {
        self.DeliveredBlocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_DeliveredBlocks(&mut self, v: i32) {
        self.DeliveredBlocks = v;
    }

    // int32 TotalBlocksOnTime = 5;


    pub fn get_TotalBlocksOnTime(&self) -> i32 {
        self.TotalBlocksOnTime
    }
    pub fn clear_TotalBlocksOnTime(&mut self) {
        self.TotalBlocksOnTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalBlocksOnTime(&mut self, v: i32) {
        self.TotalBlocksOnTime = v;
    }

    // double TardinessMean = 6;


    pub fn get_TardinessMean(&self) -> f64 {
        self.TardinessMean
    }
    pub fn clear_TardinessMean(&mut self) {
        self.TardinessMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_TardinessMean(&mut self, v: f64) {
        self.TardinessMean = v;
    }

    // double ShuffleBufferUtilizationMean = 7;


    pub fn get_ShuffleBufferUtilizationMean(&self) -> f64 {
        self.ShuffleBufferUtilizationMean
    }
    pub fn clear_ShuffleBufferUtilizationMean(&mut self) {
        self.ShuffleBufferUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ShuffleBufferUtilizationMean(&mut self, v: f64) {
        self.ShuffleBufferUtilizationMean = v;
    }

    // double SortedBufferUtilizationMean = 8;


    pub fn get_SortedBufferUtilizationMean(&self) -> f64 {
        self.SortedBufferUtilizationMean
    }
    pub fn clear_SortedBufferUtilizationMean(&mut self) {
        self.SortedBufferUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_SortedBufferUtilizationMean(&mut self, v: f64) {
        self.SortedBufferUtilizationMean = v;
    }

    // double ShuffleCraneUtilizationMean = 9;


    pub fn get_ShuffleCraneUtilizationMean(&self) -> f64 {
        self.ShuffleCraneUtilizationMean
    }
    pub fn clear_ShuffleCraneUtilizationMean(&mut self) {
        self.ShuffleCraneUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ShuffleCraneUtilizationMean(&mut self, v: f64) {
        self.ShuffleCraneUtilizationMean = v;
    }

    // double HandoverCraneUtilizationMean = 10;


    pub fn get_HandoverCraneUtilizationMean(&self) -> f64 {
        self.HandoverCraneUtilizationMean
    }
    pub fn clear_HandoverCraneUtilizationMean(&mut self) {
        self.HandoverCraneUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_HandoverCraneUtilizationMean(&mut self, v: f64) {
        self.HandoverCraneUtilizationMean = v;
    }

    // double MillAUtilizationMean = 11;


    pub fn get_MillAUtilizationMean(&self) -> f64 {
        self.MillAUtilizationMean
    }
    pub fn clear_MillAUtilizationMean(&mut self) {
        self.MillAUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_MillAUtilizationMean(&mut self, v: f64) {
        self.MillAUtilizationMean = v;
    }

    // double MillBUtilizationMean = 12;


    pub fn get_MillBUtilizationMean(&self) -> f64 {
        self.MillBUtilizationMean
    }
    pub fn clear_MillBUtilizationMean(&mut self) {
        self.MillBUtilizationMean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_MillBUtilizationMean(&mut self, v: f64) {
        self.MillBUtilizationMean = v;
    }

    // int32 RollingProgramMessups = 13;


    pub fn get_RollingProgramMessups(&self) -> i32 {
        self.RollingProgramMessups
    }
    pub fn clear_RollingProgramMessups(&mut self) {
        self.RollingProgramMessups = 0;
    }

    // Param is passed by value, moved
    pub fn set_RollingProgramMessups(&mut self, v: i32) {
        self.RollingProgramMessups = v;
    }

    // double BlockedMillTime = 14;


    pub fn get_BlockedMillTime(&self) -> f64 {
        self.BlockedMillTime
    }
    pub fn clear_BlockedMillTime(&mut self) {
        self.BlockedMillTime = 0.;
    }

    // Param is passed by value, moved
    pub fn set_BlockedMillTime(&mut self, v: f64) {
        self.BlockedMillTime = v;
    }
}

impl ::protobuf::Message for Performance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CraneManipulations = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ServiceLevelMean = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.LeadTimeMean = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.DeliveredBlocks = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.TotalBlocksOnTime = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.TardinessMean = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ShuffleBufferUtilizationMean = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.SortedBufferUtilizationMean = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ShuffleCraneUtilizationMean = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.HandoverCraneUtilizationMean = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.MillAUtilizationMean = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.MillBUtilizationMean = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.RollingProgramMessups = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.BlockedMillTime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.CraneManipulations != 0 {
            my_size += ::protobuf::rt::value_size(1, self.CraneManipulations, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ServiceLevelMean != 0. {
            my_size += 9;
        }
        if self.LeadTimeMean != 0. {
            my_size += 9;
        }
        if self.DeliveredBlocks != 0 {
            my_size += ::protobuf::rt::value_size(4, self.DeliveredBlocks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalBlocksOnTime != 0 {
            my_size += ::protobuf::rt::value_size(5, self.TotalBlocksOnTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TardinessMean != 0. {
            my_size += 9;
        }
        if self.ShuffleBufferUtilizationMean != 0. {
            my_size += 9;
        }
        if self.SortedBufferUtilizationMean != 0. {
            my_size += 9;
        }
        if self.ShuffleCraneUtilizationMean != 0. {
            my_size += 9;
        }
        if self.HandoverCraneUtilizationMean != 0. {
            my_size += 9;
        }
        if self.MillAUtilizationMean != 0. {
            my_size += 9;
        }
        if self.MillBUtilizationMean != 0. {
            my_size += 9;
        }
        if self.RollingProgramMessups != 0 {
            my_size += ::protobuf::rt::value_size(13, self.RollingProgramMessups, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BlockedMillTime != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.CraneManipulations != 0 {
            os.write_int32(1, self.CraneManipulations)?;
        }
        if self.ServiceLevelMean != 0. {
            os.write_double(2, self.ServiceLevelMean)?;
        }
        if self.LeadTimeMean != 0. {
            os.write_double(3, self.LeadTimeMean)?;
        }
        if self.DeliveredBlocks != 0 {
            os.write_int32(4, self.DeliveredBlocks)?;
        }
        if self.TotalBlocksOnTime != 0 {
            os.write_int32(5, self.TotalBlocksOnTime)?;
        }
        if self.TardinessMean != 0. {
            os.write_double(6, self.TardinessMean)?;
        }
        if self.ShuffleBufferUtilizationMean != 0. {
            os.write_double(7, self.ShuffleBufferUtilizationMean)?;
        }
        if self.SortedBufferUtilizationMean != 0. {
            os.write_double(8, self.SortedBufferUtilizationMean)?;
        }
        if self.ShuffleCraneUtilizationMean != 0. {
            os.write_double(9, self.ShuffleCraneUtilizationMean)?;
        }
        if self.HandoverCraneUtilizationMean != 0. {
            os.write_double(10, self.HandoverCraneUtilizationMean)?;
        }
        if self.MillAUtilizationMean != 0. {
            os.write_double(11, self.MillAUtilizationMean)?;
        }
        if self.MillBUtilizationMean != 0. {
            os.write_double(12, self.MillBUtilizationMean)?;
        }
        if self.RollingProgramMessups != 0 {
            os.write_int32(13, self.RollingProgramMessups)?;
        }
        if self.BlockedMillTime != 0. {
            os.write_double(14, self.BlockedMillTime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Performance {
        Performance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "CraneManipulations",
                    |m: &Performance| { &m.CraneManipulations },
                    |m: &mut Performance| { &mut m.CraneManipulations },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ServiceLevelMean",
                    |m: &Performance| { &m.ServiceLevelMean },
                    |m: &mut Performance| { &mut m.ServiceLevelMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "LeadTimeMean",
                    |m: &Performance| { &m.LeadTimeMean },
                    |m: &mut Performance| { &mut m.LeadTimeMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "DeliveredBlocks",
                    |m: &Performance| { &m.DeliveredBlocks },
                    |m: &mut Performance| { &mut m.DeliveredBlocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "TotalBlocksOnTime",
                    |m: &Performance| { &m.TotalBlocksOnTime },
                    |m: &mut Performance| { &mut m.TotalBlocksOnTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "TardinessMean",
                    |m: &Performance| { &m.TardinessMean },
                    |m: &mut Performance| { &mut m.TardinessMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ShuffleBufferUtilizationMean",
                    |m: &Performance| { &m.ShuffleBufferUtilizationMean },
                    |m: &mut Performance| { &mut m.ShuffleBufferUtilizationMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "SortedBufferUtilizationMean",
                    |m: &Performance| { &m.SortedBufferUtilizationMean },
                    |m: &mut Performance| { &mut m.SortedBufferUtilizationMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ShuffleCraneUtilizationMean",
                    |m: &Performance| { &m.ShuffleCraneUtilizationMean },
                    |m: &mut Performance| { &mut m.ShuffleCraneUtilizationMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "HandoverCraneUtilizationMean",
                    |m: &Performance| { &m.HandoverCraneUtilizationMean },
                    |m: &mut Performance| { &mut m.HandoverCraneUtilizationMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "MillAUtilizationMean",
                    |m: &Performance| { &m.MillAUtilizationMean },
                    |m: &mut Performance| { &mut m.MillAUtilizationMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "MillBUtilizationMean",
                    |m: &Performance| { &m.MillBUtilizationMean },
                    |m: &mut Performance| { &mut m.MillBUtilizationMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "RollingProgramMessups",
                    |m: &Performance| { &m.RollingProgramMessups },
                    |m: &mut Performance| { &mut m.RollingProgramMessups },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "BlockedMillTime",
                    |m: &Performance| { &m.BlockedMillTime },
                    |m: &mut Performance| { &mut m.BlockedMillTime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Performance>(
                    "Performance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Performance {
        static mut instance: ::protobuf::lazy::Lazy<Performance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Performance,
        };
        unsafe {
            instance.get(Performance::new)
        }
    }
}

impl ::protobuf::Clear for Performance {
    fn clear(&mut self) {
        self.CraneManipulations = 0;
        self.ServiceLevelMean = 0.;
        self.LeadTimeMean = 0.;
        self.DeliveredBlocks = 0;
        self.TotalBlocksOnTime = 0;
        self.TardinessMean = 0.;
        self.ShuffleBufferUtilizationMean = 0.;
        self.SortedBufferUtilizationMean = 0.;
        self.ShuffleCraneUtilizationMean = 0.;
        self.HandoverCraneUtilizationMean = 0.;
        self.MillAUtilizationMean = 0.;
        self.MillBUtilizationMean = 0.;
        self.RollingProgramMessups = 0;
        self.BlockedMillTime = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Performance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Performance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlannedCraneMoves {
    // message fields
    pub SequenceNr: i32,
    pub Moves: ::protobuf::RepeatedField<CraneMove>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlannedCraneMoves {
    fn default() -> &'a PlannedCraneMoves {
        <PlannedCraneMoves as ::protobuf::Message>::default_instance()
    }
}

impl PlannedCraneMoves {
    pub fn new() -> PlannedCraneMoves {
        ::std::default::Default::default()
    }

    // int32 SequenceNr = 1;


    pub fn get_SequenceNr(&self) -> i32 {
        self.SequenceNr
    }
    pub fn clear_SequenceNr(&mut self) {
        self.SequenceNr = 0;
    }

    // Param is passed by value, moved
    pub fn set_SequenceNr(&mut self, v: i32) {
        self.SequenceNr = v;
    }

    // repeated .DynStacking.RollingMill.DataModel.CraneMove Moves = 2;


    pub fn get_Moves(&self) -> &[CraneMove] {
        &self.Moves
    }
    pub fn clear_Moves(&mut self) {
        self.Moves.clear();
    }

    // Param is passed by value, moved
    pub fn set_Moves(&mut self, v: ::protobuf::RepeatedField<CraneMove>) {
        self.Moves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Moves(&mut self) -> &mut ::protobuf::RepeatedField<CraneMove> {
        &mut self.Moves
    }

    // Take field
    pub fn take_Moves(&mut self) -> ::protobuf::RepeatedField<CraneMove> {
        ::std::mem::replace(&mut self.Moves, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PlannedCraneMoves {
    fn is_initialized(&self) -> bool {
        for v in &self.Moves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.SequenceNr = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Moves)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SequenceNr != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SequenceNr, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.Moves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SequenceNr != 0 {
            os.write_int32(1, self.SequenceNr)?;
        }
        for v in &self.Moves {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlannedCraneMoves {
        PlannedCraneMoves::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "SequenceNr",
                    |m: &PlannedCraneMoves| { &m.SequenceNr },
                    |m: &mut PlannedCraneMoves| { &mut m.SequenceNr },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneMove>>(
                    "Moves",
                    |m: &PlannedCraneMoves| { &m.Moves },
                    |m: &mut PlannedCraneMoves| { &mut m.Moves },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlannedCraneMoves>(
                    "PlannedCraneMoves",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlannedCraneMoves {
        static mut instance: ::protobuf::lazy::Lazy<PlannedCraneMoves> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlannedCraneMoves,
        };
        unsafe {
            instance.get(PlannedCraneMoves::new)
        }
    }
}

impl ::protobuf::Clear for PlannedCraneMoves {
    fn clear(&mut self) {
        self.SequenceNr = 0;
        self.Moves.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlannedCraneMoves {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlannedCraneMoves {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stack {
    // message fields
    pub BottomToTop: ::protobuf::RepeatedField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Stack {
    fn default() -> &'a Stack {
        <Stack as ::protobuf::Message>::default_instance()
    }
}

impl Stack {
    pub fn new() -> Stack {
        ::std::default::Default::default()
    }

    // repeated .DynStacking.RollingMill.DataModel.Block BottomToTop = 1;


    pub fn get_BottomToTop(&self) -> &[Block] {
        &self.BottomToTop
    }
    pub fn clear_BottomToTop(&mut self) {
        self.BottomToTop.clear();
    }

    // Param is passed by value, moved
    pub fn set_BottomToTop(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.BottomToTop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_BottomToTop(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.BottomToTop
    }

    // Take field
    pub fn take_BottomToTop(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.BottomToTop, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Stack {
    fn is_initialized(&self) -> bool {
        for v in &self.BottomToTop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.BottomToTop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.BottomToTop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.BottomToTop {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stack {
        Stack::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "BottomToTop",
                    |m: &Stack| { &m.BottomToTop },
                    |m: &mut Stack| { &mut m.BottomToTop },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stack>(
                    "Stack",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Stack {
        static mut instance: ::protobuf::lazy::Lazy<Stack> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Stack,
        };
        unsafe {
            instance.get(Stack::new)
        }
    }
}

impl ::protobuf::Clear for Stack {
    fn clear(&mut self) {
        self.BottomToTop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stack {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeStamp {
    // message fields
    pub MilliSeconds: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeStamp {
    fn default() -> &'a TimeStamp {
        <TimeStamp as ::protobuf::Message>::default_instance()
    }
}

impl TimeStamp {
    pub fn new() -> TimeStamp {
        ::std::default::Default::default()
    }

    // int64 MilliSeconds = 1;


    pub fn get_MilliSeconds(&self) -> i64 {
        self.MilliSeconds
    }
    pub fn clear_MilliSeconds(&mut self) {
        self.MilliSeconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_MilliSeconds(&mut self, v: i64) {
        self.MilliSeconds = v;
    }
}

impl ::protobuf::Message for TimeStamp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.MilliSeconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.MilliSeconds != 0 {
            my_size += ::protobuf::rt::value_size(1, self.MilliSeconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.MilliSeconds != 0 {
            os.write_int64(1, self.MilliSeconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeStamp {
        TimeStamp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "MilliSeconds",
                    |m: &TimeStamp| { &m.MilliSeconds },
                    |m: &mut TimeStamp| { &mut m.MilliSeconds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeStamp>(
                    "TimeStamp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimeStamp {
        static mut instance: ::protobuf::lazy::Lazy<TimeStamp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeStamp,
        };
        unsafe {
            instance.get(TimeStamp::new)
        }
    }
}

impl ::protobuf::Clear for TimeStamp {
    fn clear(&mut self) {
        self.MilliSeconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeStamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeStamp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Uncertainties {
    // message fields
    pub ArrivalIntervals: ::std::vec::Vec<f64>,
    pub CraneMoveTimes: ::std::vec::Vec<f64>,
    pub MillBlockIntervals: ::std::vec::Vec<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Uncertainties {
    fn default() -> &'a Uncertainties {
        <Uncertainties as ::protobuf::Message>::default_instance()
    }
}

impl Uncertainties {
    pub fn new() -> Uncertainties {
        ::std::default::Default::default()
    }

    // repeated double ArrivalIntervals = 1;


    pub fn get_ArrivalIntervals(&self) -> &[f64] {
        &self.ArrivalIntervals
    }
    pub fn clear_ArrivalIntervals(&mut self) {
        self.ArrivalIntervals.clear();
    }

    // Param is passed by value, moved
    pub fn set_ArrivalIntervals(&mut self, v: ::std::vec::Vec<f64>) {
        self.ArrivalIntervals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ArrivalIntervals(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.ArrivalIntervals
    }

    // Take field
    pub fn take_ArrivalIntervals(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.ArrivalIntervals, ::std::vec::Vec::new())
    }

    // repeated double CraneMoveTimes = 2;


    pub fn get_CraneMoveTimes(&self) -> &[f64] {
        &self.CraneMoveTimes
    }
    pub fn clear_CraneMoveTimes(&mut self) {
        self.CraneMoveTimes.clear();
    }

    // Param is passed by value, moved
    pub fn set_CraneMoveTimes(&mut self, v: ::std::vec::Vec<f64>) {
        self.CraneMoveTimes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CraneMoveTimes(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.CraneMoveTimes
    }

    // Take field
    pub fn take_CraneMoveTimes(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.CraneMoveTimes, ::std::vec::Vec::new())
    }

    // repeated double MillBlockIntervals = 3;


    pub fn get_MillBlockIntervals(&self) -> &[f64] {
        &self.MillBlockIntervals
    }
    pub fn clear_MillBlockIntervals(&mut self) {
        self.MillBlockIntervals.clear();
    }

    // Param is passed by value, moved
    pub fn set_MillBlockIntervals(&mut self, v: ::std::vec::Vec<f64>) {
        self.MillBlockIntervals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_MillBlockIntervals(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.MillBlockIntervals
    }

    // Take field
    pub fn take_MillBlockIntervals(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.MillBlockIntervals, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Uncertainties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.ArrivalIntervals)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.CraneMoveTimes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.MillBlockIntervals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.ArrivalIntervals.len() as u32;
        my_size += 9 * self.CraneMoveTimes.len() as u32;
        my_size += 9 * self.MillBlockIntervals.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ArrivalIntervals {
            os.write_double(1, *v)?;
        };
        for v in &self.CraneMoveTimes {
            os.write_double(2, *v)?;
        };
        for v in &self.MillBlockIntervals {
            os.write_double(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Uncertainties {
        Uncertainties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ArrivalIntervals",
                    |m: &Uncertainties| { &m.ArrivalIntervals },
                    |m: &mut Uncertainties| { &mut m.ArrivalIntervals },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "CraneMoveTimes",
                    |m: &Uncertainties| { &m.CraneMoveTimes },
                    |m: &mut Uncertainties| { &mut m.CraneMoveTimes },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "MillBlockIntervals",
                    |m: &Uncertainties| { &m.MillBlockIntervals },
                    |m: &mut Uncertainties| { &mut m.MillBlockIntervals },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Uncertainties>(
                    "Uncertainties",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Uncertainties {
        static mut instance: ::protobuf::lazy::Lazy<Uncertainties> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Uncertainties,
        };
        unsafe {
            instance.get(Uncertainties::new)
        }
    }
}

impl ::protobuf::Clear for Uncertainties {
    fn clear(&mut self) {
        self.ArrivalIntervals.clear();
        self.CraneMoveTimes.clear();
        self.MillBlockIntervals.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Uncertainties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uncertainties {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct World {
    // message fields
    pub Now: ::protobuf::SingularPtrField<TimeStamp>,
    pub Height: i32,
    pub Width: f64,
    pub Locations: ::protobuf::RepeatedField<Location>,
    pub BlocksAtSlabYard: ::protobuf::RepeatedField<Block>,
    pub ArrivalsFromSlabYard: ::protobuf::RepeatedField<Arrival>,
    pub CraneMoves: ::protobuf::SingularPtrField<PlannedCraneMoves>,
    pub MoveRequests: ::protobuf::RepeatedField<MoveRequest>,
    pub CraneSchedule: ::protobuf::SingularPtrField<CraneSchedule>,
    pub ShuffleCrane: ::protobuf::SingularPtrField<Crane>,
    pub HandoverCrane: ::protobuf::SingularPtrField<Crane>,
    pub KPIs: ::protobuf::SingularPtrField<Performance>,
    pub ObservationData: ::protobuf::SingularPtrField<Uncertainties>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a World {
    fn default() -> &'a World {
        <World as ::protobuf::Message>::default_instance()
    }
}

impl World {
    pub fn new() -> World {
        ::std::default::Default::default()
    }

    // .DynStacking.RollingMill.DataModel.TimeStamp Now = 1;


    pub fn get_Now(&self) -> &TimeStamp {
        self.Now.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_Now(&mut self) {
        self.Now.clear();
    }

    pub fn has_Now(&self) -> bool {
        self.Now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Now(&mut self, v: TimeStamp) {
        self.Now = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Now(&mut self) -> &mut TimeStamp {
        if self.Now.is_none() {
            self.Now.set_default();
        }
        self.Now.as_mut().unwrap()
    }

    // Take field
    pub fn take_Now(&mut self) -> TimeStamp {
        self.Now.take().unwrap_or_else(|| TimeStamp::new())
    }

    // int32 Height = 2;


    pub fn get_Height(&self) -> i32 {
        self.Height
    }
    pub fn clear_Height(&mut self) {
        self.Height = 0;
    }

    // Param is passed by value, moved
    pub fn set_Height(&mut self, v: i32) {
        self.Height = v;
    }

    // double Width = 3;


    pub fn get_Width(&self) -> f64 {
        self.Width
    }
    pub fn clear_Width(&mut self) {
        self.Width = 0.;
    }

    // Param is passed by value, moved
    pub fn set_Width(&mut self, v: f64) {
        self.Width = v;
    }

    // repeated .DynStacking.RollingMill.DataModel.Location Locations = 4;


    pub fn get_Locations(&self) -> &[Location] {
        &self.Locations
    }
    pub fn clear_Locations(&mut self) {
        self.Locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_Locations(&mut self, v: ::protobuf::RepeatedField<Location>) {
        self.Locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Locations(&mut self) -> &mut ::protobuf::RepeatedField<Location> {
        &mut self.Locations
    }

    // Take field
    pub fn take_Locations(&mut self) -> ::protobuf::RepeatedField<Location> {
        ::std::mem::replace(&mut self.Locations, ::protobuf::RepeatedField::new())
    }

    // repeated .DynStacking.RollingMill.DataModel.Block BlocksAtSlabYard = 5;


    pub fn get_BlocksAtSlabYard(&self) -> &[Block] {
        &self.BlocksAtSlabYard
    }
    pub fn clear_BlocksAtSlabYard(&mut self) {
        self.BlocksAtSlabYard.clear();
    }

    // Param is passed by value, moved
    pub fn set_BlocksAtSlabYard(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.BlocksAtSlabYard = v;
    }

    // Mutable pointer to the field.
    pub fn mut_BlocksAtSlabYard(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.BlocksAtSlabYard
    }

    // Take field
    pub fn take_BlocksAtSlabYard(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.BlocksAtSlabYard, ::protobuf::RepeatedField::new())
    }

    // repeated .DynStacking.RollingMill.DataModel.Arrival ArrivalsFromSlabYard = 6;


    pub fn get_ArrivalsFromSlabYard(&self) -> &[Arrival] {
        &self.ArrivalsFromSlabYard
    }
    pub fn clear_ArrivalsFromSlabYard(&mut self) {
        self.ArrivalsFromSlabYard.clear();
    }

    // Param is passed by value, moved
    pub fn set_ArrivalsFromSlabYard(&mut self, v: ::protobuf::RepeatedField<Arrival>) {
        self.ArrivalsFromSlabYard = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ArrivalsFromSlabYard(&mut self) -> &mut ::protobuf::RepeatedField<Arrival> {
        &mut self.ArrivalsFromSlabYard
    }

    // Take field
    pub fn take_ArrivalsFromSlabYard(&mut self) -> ::protobuf::RepeatedField<Arrival> {
        ::std::mem::replace(&mut self.ArrivalsFromSlabYard, ::protobuf::RepeatedField::new())
    }

    // .DynStacking.RollingMill.DataModel.PlannedCraneMoves CraneMoves = 7;


    pub fn get_CraneMoves(&self) -> &PlannedCraneMoves {
        self.CraneMoves.as_ref().unwrap_or_else(|| PlannedCraneMoves::default_instance())
    }
    pub fn clear_CraneMoves(&mut self) {
        self.CraneMoves.clear();
    }

    pub fn has_CraneMoves(&self) -> bool {
        self.CraneMoves.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CraneMoves(&mut self, v: PlannedCraneMoves) {
        self.CraneMoves = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CraneMoves(&mut self) -> &mut PlannedCraneMoves {
        if self.CraneMoves.is_none() {
            self.CraneMoves.set_default();
        }
        self.CraneMoves.as_mut().unwrap()
    }

    // Take field
    pub fn take_CraneMoves(&mut self) -> PlannedCraneMoves {
        self.CraneMoves.take().unwrap_or_else(|| PlannedCraneMoves::new())
    }

    // repeated .DynStacking.RollingMill.DataModel.MoveRequest MoveRequests = 8;


    pub fn get_MoveRequests(&self) -> &[MoveRequest] {
        &self.MoveRequests
    }
    pub fn clear_MoveRequests(&mut self) {
        self.MoveRequests.clear();
    }

    // Param is passed by value, moved
    pub fn set_MoveRequests(&mut self, v: ::protobuf::RepeatedField<MoveRequest>) {
        self.MoveRequests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_MoveRequests(&mut self) -> &mut ::protobuf::RepeatedField<MoveRequest> {
        &mut self.MoveRequests
    }

    // Take field
    pub fn take_MoveRequests(&mut self) -> ::protobuf::RepeatedField<MoveRequest> {
        ::std::mem::replace(&mut self.MoveRequests, ::protobuf::RepeatedField::new())
    }

    // .DynStacking.RollingMill.DataModel.CraneSchedule CraneSchedule = 9;


    pub fn get_CraneSchedule(&self) -> &CraneSchedule {
        self.CraneSchedule.as_ref().unwrap_or_else(|| CraneSchedule::default_instance())
    }
    pub fn clear_CraneSchedule(&mut self) {
        self.CraneSchedule.clear();
    }

    pub fn has_CraneSchedule(&self) -> bool {
        self.CraneSchedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CraneSchedule(&mut self, v: CraneSchedule) {
        self.CraneSchedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CraneSchedule(&mut self) -> &mut CraneSchedule {
        if self.CraneSchedule.is_none() {
            self.CraneSchedule.set_default();
        }
        self.CraneSchedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_CraneSchedule(&mut self) -> CraneSchedule {
        self.CraneSchedule.take().unwrap_or_else(|| CraneSchedule::new())
    }

    // .DynStacking.RollingMill.DataModel.Crane ShuffleCrane = 10;


    pub fn get_ShuffleCrane(&self) -> &Crane {
        self.ShuffleCrane.as_ref().unwrap_or_else(|| Crane::default_instance())
    }
    pub fn clear_ShuffleCrane(&mut self) {
        self.ShuffleCrane.clear();
    }

    pub fn has_ShuffleCrane(&self) -> bool {
        self.ShuffleCrane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ShuffleCrane(&mut self, v: Crane) {
        self.ShuffleCrane = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ShuffleCrane(&mut self) -> &mut Crane {
        if self.ShuffleCrane.is_none() {
            self.ShuffleCrane.set_default();
        }
        self.ShuffleCrane.as_mut().unwrap()
    }

    // Take field
    pub fn take_ShuffleCrane(&mut self) -> Crane {
        self.ShuffleCrane.take().unwrap_or_else(|| Crane::new())
    }

    // .DynStacking.RollingMill.DataModel.Crane HandoverCrane = 11;


    pub fn get_HandoverCrane(&self) -> &Crane {
        self.HandoverCrane.as_ref().unwrap_or_else(|| Crane::default_instance())
    }
    pub fn clear_HandoverCrane(&mut self) {
        self.HandoverCrane.clear();
    }

    pub fn has_HandoverCrane(&self) -> bool {
        self.HandoverCrane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_HandoverCrane(&mut self, v: Crane) {
        self.HandoverCrane = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HandoverCrane(&mut self) -> &mut Crane {
        if self.HandoverCrane.is_none() {
            self.HandoverCrane.set_default();
        }
        self.HandoverCrane.as_mut().unwrap()
    }

    // Take field
    pub fn take_HandoverCrane(&mut self) -> Crane {
        self.HandoverCrane.take().unwrap_or_else(|| Crane::new())
    }

    // .DynStacking.RollingMill.DataModel.Performance KPIs = 12;


    pub fn get_KPIs(&self) -> &Performance {
        self.KPIs.as_ref().unwrap_or_else(|| Performance::default_instance())
    }
    pub fn clear_KPIs(&mut self) {
        self.KPIs.clear();
    }

    pub fn has_KPIs(&self) -> bool {
        self.KPIs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_KPIs(&mut self, v: Performance) {
        self.KPIs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_KPIs(&mut self) -> &mut Performance {
        if self.KPIs.is_none() {
            self.KPIs.set_default();
        }
        self.KPIs.as_mut().unwrap()
    }

    // Take field
    pub fn take_KPIs(&mut self) -> Performance {
        self.KPIs.take().unwrap_or_else(|| Performance::new())
    }

    // .DynStacking.RollingMill.DataModel.Uncertainties ObservationData = 13;


    pub fn get_ObservationData(&self) -> &Uncertainties {
        self.ObservationData.as_ref().unwrap_or_else(|| Uncertainties::default_instance())
    }
    pub fn clear_ObservationData(&mut self) {
        self.ObservationData.clear();
    }

    pub fn has_ObservationData(&self) -> bool {
        self.ObservationData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ObservationData(&mut self, v: Uncertainties) {
        self.ObservationData = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ObservationData(&mut self) -> &mut Uncertainties {
        if self.ObservationData.is_none() {
            self.ObservationData.set_default();
        }
        self.ObservationData.as_mut().unwrap()
    }

    // Take field
    pub fn take_ObservationData(&mut self) -> Uncertainties {
        self.ObservationData.take().unwrap_or_else(|| Uncertainties::new())
    }
}

impl ::protobuf::Message for World {
    fn is_initialized(&self) -> bool {
        for v in &self.Now {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.BlocksAtSlabYard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ArrivalsFromSlabYard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CraneMoves {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.MoveRequests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CraneSchedule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ShuffleCrane {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HandoverCrane {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.KPIs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ObservationData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Now)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.Width = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Locations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.BlocksAtSlabYard)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ArrivalsFromSlabYard)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CraneMoves)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.MoveRequests)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CraneSchedule)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ShuffleCrane)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.HandoverCrane)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.KPIs)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ObservationData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.Height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Width != 0. {
            my_size += 9;
        }
        for value in &self.Locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.BlocksAtSlabYard {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ArrivalsFromSlabYard {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.CraneMoves.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.MoveRequests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.CraneSchedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ShuffleCrane.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.HandoverCrane.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.KPIs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ObservationData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Now.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.Height != 0 {
            os.write_int32(2, self.Height)?;
        }
        if self.Width != 0. {
            os.write_double(3, self.Width)?;
        }
        for v in &self.Locations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.BlocksAtSlabYard {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ArrivalsFromSlabYard {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.CraneMoves.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.MoveRequests {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.CraneSchedule.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ShuffleCrane.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.HandoverCrane.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.KPIs.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ObservationData.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> World {
        World::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "Now",
                    |m: &World| { &m.Now },
                    |m: &mut World| { &mut m.Now },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Height",
                    |m: &World| { &m.Height },
                    |m: &mut World| { &mut m.Height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "Width",
                    |m: &World| { &m.Width },
                    |m: &mut World| { &mut m.Width },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Location>>(
                    "Locations",
                    |m: &World| { &m.Locations },
                    |m: &mut World| { &mut m.Locations },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "BlocksAtSlabYard",
                    |m: &World| { &m.BlocksAtSlabYard },
                    |m: &mut World| { &mut m.BlocksAtSlabYard },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Arrival>>(
                    "ArrivalsFromSlabYard",
                    |m: &World| { &m.ArrivalsFromSlabYard },
                    |m: &mut World| { &mut m.ArrivalsFromSlabYard },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlannedCraneMoves>>(
                    "CraneMoves",
                    |m: &World| { &m.CraneMoves },
                    |m: &mut World| { &mut m.CraneMoves },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoveRequest>>(
                    "MoveRequests",
                    |m: &World| { &m.MoveRequests },
                    |m: &mut World| { &mut m.MoveRequests },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneSchedule>>(
                    "CraneSchedule",
                    |m: &World| { &m.CraneSchedule },
                    |m: &mut World| { &mut m.CraneSchedule },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Crane>>(
                    "ShuffleCrane",
                    |m: &World| { &m.ShuffleCrane },
                    |m: &mut World| { &mut m.ShuffleCrane },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Crane>>(
                    "HandoverCrane",
                    |m: &World| { &m.HandoverCrane },
                    |m: &mut World| { &mut m.HandoverCrane },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Performance>>(
                    "KPIs",
                    |m: &World| { &m.KPIs },
                    |m: &mut World| { &mut m.KPIs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uncertainties>>(
                    "ObservationData",
                    |m: &World| { &m.ObservationData },
                    |m: &mut World| { &mut m.ObservationData },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<World>(
                    "World",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static World {
        static mut instance: ::protobuf::lazy::Lazy<World> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const World,
        };
        unsafe {
            instance.get(World::new)
        }
    }
}

impl ::protobuf::Clear for World {
    fn clear(&mut self) {
        self.Now.clear();
        self.Height = 0;
        self.Width = 0.;
        self.Locations.clear();
        self.BlocksAtSlabYard.clear();
        self.ArrivalsFromSlabYard.clear();
        self.CraneMoves.clear();
        self.MoveRequests.clear();
        self.CraneSchedule.clear();
        self.ShuffleCrane.clear();
        self.HandoverCrane.clear();
        self.KPIs.clear();
        self.ObservationData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for World {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for World {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MillTypes {
    A = 0,
    B = 1,
}

impl ::protobuf::ProtobufEnum for MillTypes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MillTypes> {
        match value {
            0 => ::std::option::Option::Some(MillTypes::A),
            1 => ::std::option::Option::Some(MillTypes::B),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MillTypes] = &[
            MillTypes::A,
            MillTypes::B,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MillTypes", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MillTypes {
}

impl ::std::default::Default for MillTypes {
    fn default() -> Self {
        MillTypes::A
    }
}

impl ::protobuf::reflect::ProtobufValue for MillTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MoveType {
    MoveToPickup = 0,
    PickupAndDropoff = 1,
}

impl ::protobuf::ProtobufEnum for MoveType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MoveType> {
        match value {
            0 => ::std::option::Option::Some(MoveType::MoveToPickup),
            1 => ::std::option::Option::Some(MoveType::PickupAndDropoff),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MoveType] = &[
            MoveType::MoveToPickup,
            MoveType::PickupAndDropoff,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MoveType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MoveType {
}

impl ::std::default::Default for MoveType {
    fn default() -> Self {
        MoveType::MoveToPickup
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StackTypes {
    ArrivalStack = 0,
    ShuffleBuffer = 1,
    SortedBuffer = 2,
    HandoverStack = 3,
}

impl ::protobuf::ProtobufEnum for StackTypes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StackTypes> {
        match value {
            0 => ::std::option::Option::Some(StackTypes::ArrivalStack),
            1 => ::std::option::Option::Some(StackTypes::ShuffleBuffer),
            2 => ::std::option::Option::Some(StackTypes::SortedBuffer),
            3 => ::std::option::Option::Some(StackTypes::HandoverStack),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StackTypes] = &[
            StackTypes::ArrivalStack,
            StackTypes::ShuffleBuffer,
            StackTypes::SortedBuffer,
            StackTypes::HandoverStack,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StackTypes", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StackTypes {
}

impl ::std::default::Default for StackTypes {
    fn default() -> Self {
        StackTypes::ArrivalStack
    }
}

impl ::protobuf::reflect::ProtobufValue for StackTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17rollingmill_model.proto\x12!DynStacking.RollingMill.DataModel\"\
    \xb9\x01\n\x07Arrival\x12\x18\n\x07Vehicle\x18\x01\x20\x01(\x05R\x07Vehi\
    cle\x12<\n\x04Load\x18\x02\x20\x01(\x0b2(.DynStacking.RollingMill.DataMo\
    del.StackR\x04Load\x12V\n\x0fArrivalEstimate\x18\x03\x20\x01(\x0b2,.DynS\
    tacking.RollingMill.DataModel.TimeStampR\x0fArrivalEstimate\"\xf3\x01\n\
    \x05Block\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\x12\x1a\n\x08Seque\
    nce\x18\x02\x20\x01(\x05R\x08Sequence\x12@\n\x04Type\x18\x03\x20\x01(\
    \x0e2,.DynStacking.RollingMill.DataModel.MillTypesR\x04Type\x12\x1c\n\tP\
    rogramId\x18\x04\x20\x01(\x05R\tProgramId\x12F\n\x07Arrived\x18\x05\x20\
    \x01(\x0b2,.DynStacking.RollingMill.DataModel.TimeStampR\x07Arrived\x12\
    \x16\n\x06Rolled\x18\x06\x20\x01(\x08R\x06Rolled\"\x9d\x02\n\x05Crane\
    \x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\x12<\n\x04Load\x18\x02\x20\
    \x01(\x0b2(.DynStacking.RollingMill.DataModel.StackR\x04Load\x12&\n\x0eG\
    irderPosition\x18\x03\x20\x01(\x01R\x0eGirderPosition\x12\x1e\n\nHoistLe\
    vel\x18\x04\x20\x01(\x01R\nHoistLevel\x12$\n\rCraneCapacity\x18\x05\x20\
    \x01(\x05R\rCraneCapacity\x12\x14\n\x05Width\x18\x06\x20\x01(\x01R\x05Wi\
    dth\x12\x20\n\x0bMinPosition\x18\x07\x20\x01(\x01R\x0bMinPosition\x12\
    \x20\n\x0bMaxPosition\x18\x08\x20\x01(\x01R\x0bMaxPosition\"\xcc\x03\n\t\
    CraneMove\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\x12?\n\x04Type\x18\
    \x02\x20\x01(\x0e2+.DynStacking.RollingMill.DataModel.MoveTypeR\x04Type\
    \x12*\n\x10PickupLocationId\x18\x03\x20\x01(\x05R\x10PickupLocationId\
    \x12,\n\x11DropoffLocationId\x18\x04\x20\x01(\x05R\x11DropoffLocationId\
    \x12\x16\n\x06Amount\x18\x07\x20\x01(\x05R\x06Amount\x12N\n\x0bReleaseTi\
    me\x18\x08\x20\x01(\x0b2,.DynStacking.RollingMill.DataModel.TimeStampR\
    \x0bReleaseTime\x12F\n\x07DueDate\x18\t\x20\x01(\x0b2,.DynStacking.Rolli\
    ngMill.DataModel.TimeStampR\x07DueDate\x12(\n\x0fRequiredCraneId\x18\n\
    \x20\x01(\x05R\x0fRequiredCraneId\x12:\n\x16ProtobufPredecessorIds\x18\
    \x0b\x20\x03(\x05R\x16ProtobufPredecessorIdsB\x02\x10\0\"\x89\x01\n\rCra\
    neSchedule\x12\x1e\n\nScheduleNr\x18\x01\x20\x01(\x05R\nScheduleNr\x12X\
    \n\nActivities\x18\x02\x20\x03(\x0b28.DynStacking.RollingMill.DataModel.\
    CraneScheduleActivityR\nActivities\"e\n\x15CraneScheduleActivity\x12\x16\
    \n\x06MoveId\x18\x01\x20\x01(\x05R\x06MoveId\x12\x18\n\x07CraneId\x18\
    \x02\x20\x01(\x05R\x07CraneId\x12\x1a\n\x08Priority\x18\x03\x20\x01(\x05\
    R\x08Priority\"\xad\x02\n\x08Location\x12\x0e\n\x02Id\x18\x01\x20\x01(\
    \x05R\x02Id\x12&\n\x0eGirderPosition\x18\x02\x20\x01(\x01R\x0eGirderPosi\
    tion\x12\x1c\n\tMaxHeight\x18\x03\x20\x01(\x05R\tMaxHeight\x12>\n\x05Sta\
    ck\x18\x04\x20\x01(\x0b2(.DynStacking.RollingMill.DataModel.StackR\x05St\
    ack\x12A\n\x04Type\x18\x05\x20\x01(\x0e2-.DynStacking.RollingMill.DataMo\
    del.StackTypesR\x04Type\x12H\n\x08MillType\x18\x06\x20\x01(\x0e2,.DynSta\
    cking.RollingMill.DataModel.MillTypesR\x08MillType\"\xab\x01\n\x0bMoveRe\
    quest\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\x12*\n\x10TargetLocati\
    onId\x18\x02\x20\x01(\x05R\x10TargetLocationId\x12\x18\n\x07BlockId\x18\
    \x03\x20\x01(\x05R\x07BlockId\x12F\n\x07DueDate\x18\x04\x20\x01(\x0b2,.D\
    ynStacking.RollingMill.DataModel.TimeStampR\x07DueDate\"\xdf\x05\n\x0bPe\
    rformance\x12.\n\x12CraneManipulations\x18\x01\x20\x01(\x05R\x12CraneMan\
    ipulations\x12*\n\x10ServiceLevelMean\x18\x02\x20\x01(\x01R\x10ServiceLe\
    velMean\x12\"\n\x0cLeadTimeMean\x18\x03\x20\x01(\x01R\x0cLeadTimeMean\
    \x12(\n\x0fDeliveredBlocks\x18\x04\x20\x01(\x05R\x0fDeliveredBlocks\x12,\
    \n\x11TotalBlocksOnTime\x18\x05\x20\x01(\x05R\x11TotalBlocksOnTime\x12$\
    \n\rTardinessMean\x18\x06\x20\x01(\x01R\rTardinessMean\x12B\n\x1cShuffle\
    BufferUtilizationMean\x18\x07\x20\x01(\x01R\x1cShuffleBufferUtilizationM\
    ean\x12@\n\x1bSortedBufferUtilizationMean\x18\x08\x20\x01(\x01R\x1bSorte\
    dBufferUtilizationMean\x12@\n\x1bShuffleCraneUtilizationMean\x18\t\x20\
    \x01(\x01R\x1bShuffleCraneUtilizationMean\x12B\n\x1cHandoverCraneUtiliza\
    tionMean\x18\n\x20\x01(\x01R\x1cHandoverCraneUtilizationMean\x122\n\x14M\
    illAUtilizationMean\x18\x0b\x20\x01(\x01R\x14MillAUtilizationMean\x122\n\
    \x14MillBUtilizationMean\x18\x0c\x20\x01(\x01R\x14MillBUtilizationMean\
    \x124\n\x15RollingProgramMessups\x18\r\x20\x01(\x05R\x15RollingProgramMe\
    ssups\x12(\n\x0fBlockedMillTime\x18\x0e\x20\x01(\x01R\x0fBlockedMillTime\
    \"w\n\x11PlannedCraneMoves\x12\x1e\n\nSequenceNr\x18\x01\x20\x01(\x05R\n\
    SequenceNr\x12B\n\x05Moves\x18\x02\x20\x03(\x0b2,.DynStacking.RollingMil\
    l.DataModel.CraneMoveR\x05Moves\"S\n\x05Stack\x12J\n\x0bBottomToTop\x18\
    \x01\x20\x03(\x0b2(.DynStacking.RollingMill.DataModel.BlockR\x0bBottomTo\
    Top\"/\n\tTimeStamp\x12\"\n\x0cMilliSeconds\x18\x01\x20\x01(\x03R\x0cMil\
    liSeconds\"\x9f\x01\n\rUncertainties\x12.\n\x10ArrivalIntervals\x18\x01\
    \x20\x03(\x01R\x10ArrivalIntervalsB\x02\x10\0\x12*\n\x0eCraneMoveTimes\
    \x18\x02\x20\x03(\x01R\x0eCraneMoveTimesB\x02\x10\0\x122\n\x12MillBlockI\
    ntervals\x18\x03\x20\x03(\x01R\x12MillBlockIntervalsB\x02\x10\0\"\xb6\
    \x07\n\x05World\x12>\n\x03Now\x18\x01\x20\x01(\x0b2,.DynStacking.Rolling\
    Mill.DataModel.TimeStampR\x03Now\x12\x16\n\x06Height\x18\x02\x20\x01(\
    \x05R\x06Height\x12\x14\n\x05Width\x18\x03\x20\x01(\x01R\x05Width\x12I\n\
    \tLocations\x18\x04\x20\x03(\x0b2+.DynStacking.RollingMill.DataModel.Loc\
    ationR\tLocations\x12T\n\x10BlocksAtSlabYard\x18\x05\x20\x03(\x0b2(.DynS\
    tacking.RollingMill.DataModel.BlockR\x10BlocksAtSlabYard\x12^\n\x14Arriv\
    alsFromSlabYard\x18\x06\x20\x03(\x0b2*.DynStacking.RollingMill.DataModel\
    .ArrivalR\x14ArrivalsFromSlabYard\x12T\n\nCraneMoves\x18\x07\x20\x01(\
    \x0b24.DynStacking.RollingMill.DataModel.PlannedCraneMovesR\nCraneMoves\
    \x12R\n\x0cMoveRequests\x18\x08\x20\x03(\x0b2..DynStacking.RollingMill.D\
    ataModel.MoveRequestR\x0cMoveRequests\x12V\n\rCraneSchedule\x18\t\x20\
    \x01(\x0b20.DynStacking.RollingMill.DataModel.CraneScheduleR\rCraneSched\
    ule\x12L\n\x0cShuffleCrane\x18\n\x20\x01(\x0b2(.DynStacking.RollingMill.\
    DataModel.CraneR\x0cShuffleCrane\x12N\n\rHandoverCrane\x18\x0b\x20\x01(\
    \x0b2(.DynStacking.RollingMill.DataModel.CraneR\rHandoverCrane\x12B\n\
    \x04KPIs\x18\x0c\x20\x01(\x0b2..DynStacking.RollingMill.DataModel.Perfor\
    manceR\x04KPIs\x12Z\n\x0fObservationData\x18\r\x20\x01(\x0b20.DynStackin\
    g.RollingMill.DataModel.UncertaintiesR\x0fObservationData*\x19\n\tMillTy\
    pes\x12\x05\n\x01A\x10\0\x12\x05\n\x01B\x10\x01*2\n\x08MoveType\x12\x10\
    \n\x0cMoveToPickup\x10\0\x12\x14\n\x10PickupAndDropoff\x10\x01*V\n\nStac\
    kTypes\x12\x10\n\x0cArrivalStack\x10\0\x12\x11\n\rShuffleBuffer\x10\x01\
    \x12\x10\n\x0cSortedBuffer\x10\x02\x12\x11\n\rHandoverStack\x10\x03b\x06\
    proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
